---
description: Security rules for Electron main process and IPC communication
globs: ["src/main/**/*.ts", "src/preload/**/*.ts"]
alwaysApply: false
---

# Electron Security Rules

## Context Isolation is Non-Negotiable

Never disable context isolation or enable node integration in renderer:

```typescript
// CORRECT: Security-first configuration
const mainWindow = new BrowserWindow({
  webPreferences: {
    contextIsolation: true,      // REQUIRED: Always true
    nodeIntegration: false,      // REQUIRED: Always false
    sandbox: true,               // RECOMMENDED: Enable sandboxing
    preload: join(__dirname, '../preload/index.js'),
  }
})

// NEVER DO THIS
const insecureWindow = new BrowserWindow({
  webPreferences: {
    contextIsolation: false,  // DANGEROUS
    nodeIntegration: true,    // DANGEROUS
  }
})
```

## IPC Security Patterns

### Validate All IPC Inputs

Every IPC handler MUST validate inputs from renderer:

```typescript
import { validatePath, validateString, validateNumber } from './utils/ipcValidator'
import { isPathSafe, sanitizePath } from './utils/securityValidation'

ipcMain.handle(IPC_CHANNELS.READ_FILE, async (_, filePath: unknown) => {
  // 1. Type validation
  const path = validateString(filePath, 'filePath')
  
  // 2. Path safety check
  if (!isPathSafe(path)) {
    throw new Error('Invalid file path')
  }
  
  // 3. Sanitize the path
  const safePath = sanitizePath(path)
  
  // 4. Perform operation
  return fs.readFile(safePath)
})
```

### Use the Security Validation Utilities

Located in `src/main/utils/securityValidation.ts`:

```typescript
import { isPathSafe, sanitizePath, isWithinDirectory } from './utils/securityValidation'

// Check if path is safe (no traversal attacks)
if (!isPathSafe(userProvidedPath)) {
  throw new Error('Path validation failed')
}

// Ensure path stays within allowed directory
if (!isWithinDirectory(filePath, allowedBaseDir)) {
  throw new Error('Path outside allowed directory')
}

// Sanitize path before use
const safePath = sanitizePath(userProvidedPath)
```

### IPC Validator Functions

Use validators from `src/main/utils/ipcValidator.ts`:

```typescript
import { 
  validateString, 
  validateNumber, 
  validateBoolean,
  validateArray,
  validateObject 
} from './utils/ipcValidator'

ipcMain.handle('myChannel', async (_, arg1: unknown, arg2: unknown) => {
  const str = validateString(arg1, 'arg1')          // Throws if not string
  const num = validateNumber(arg2, 'arg2', { min: 0, max: 100 })
  // ...
})
```

## Path Validation Rules

### Never Trust Renderer Paths

Always validate and sanitize paths received from renderer:

```typescript
// Pattern: Validate → Sanitize → Verify → Use
async function handleFilePath(untrustedPath: unknown): Promise<string> {
  // 1. Validate type
  if (typeof untrustedPath !== 'string') {
    throw new Error('Path must be a string')
  }
  
  // 2. Check for traversal attacks
  if (untrustedPath.includes('..') || untrustedPath.includes('\0')) {
    throw new Error('Invalid path characters')
  }
  
  // 3. Resolve to absolute path
  const resolvedPath = path.resolve(untrustedPath)
  
  // 4. Verify it's within allowed directories
  const allowedDirs = [app.getPath('userData'), ...userSelectedDirs]
  const isAllowed = allowedDirs.some(dir => resolvedPath.startsWith(dir))
  
  if (!isAllowed) {
    throw new Error('Path not in allowed directory')
  }
  
  return resolvedPath
}
```

### Use Path Validator Module

Located in `src/main/pathValidator.ts`:

```typescript
import { PathValidator } from './pathValidator'

const validator = new PathValidator()

// Validate destination path
const isValid = validator.validateDestination(userPath)

// Get validation errors
const errors = validator.getErrors()
```

## Shell Command Safety

### Never Use shell: true with User Input

```typescript
import { execFile } from 'child_process'

// CORRECT: execFile with explicit command and args
execFile('/usr/bin/ls', ['-la', sanitizedPath], (error, stdout) => {
  // ...
})

// DANGEROUS: Never use shell: true with user input
exec(`ls -la ${userPath}`, { shell: true })  // VULNERABLE TO INJECTION
```

### Validate Before Any Shell Operations

```typescript
// If you must run external commands
const ALLOWED_COMMANDS = new Set(['ls', 'du', 'file'])

function runCommand(cmd: string, args: string[]): Promise<string> {
  if (!ALLOWED_COMMANDS.has(cmd)) {
    throw new Error(`Command not allowed: ${cmd}`)
  }
  
  // Validate all arguments
  const safeArgs = args.map(arg => {
    if (!/^[\w\-./]+$/.test(arg)) {
      throw new Error(`Invalid argument: ${arg}`)
    }
    return arg
  })
  
  return new Promise((resolve, reject) => {
    execFile(cmd, safeArgs, (error, stdout) => {
      if (error) reject(error)
      else resolve(stdout)
    })
  })
}
```

## Protocol Handlers

### Register Safe Protocol Handlers

```typescript
// Register custom protocol for local resources only
protocol.registerFileProtocol('app', (request, callback) => {
  const url = request.url.substr(6)  // Remove 'app://'
  const filePath = path.join(__dirname, url)
  
  // Verify path is within app directory
  if (!filePath.startsWith(__dirname)) {
    callback({ error: -6 })  // NET_ERROR_FILE_NOT_FOUND
    return
  }
  
  callback({ path: filePath })
})
```

## Web Content Security

### Restrict Navigation

```typescript
mainWindow.webContents.on('will-navigate', (event, url) => {
  // Only allow navigation to your app's URLs
  if (!url.startsWith('file://') && !url.startsWith(ELECTRON_RENDERER_URL)) {
    event.preventDefault()
    logger.warn('Blocked navigation to:', url)
  }
})

// Block new window creation
mainWindow.webContents.setWindowOpenHandler(({ url }) => {
  // Open external URLs in system browser
  if (url.startsWith('https://')) {
    shell.openExternal(url)
  }
  return { action: 'deny' }
})
```

## Sensitive Data Handling

### Never Log Sensitive Information

```typescript
// Bad: Logging full paths or file contents
logger.info('Processing file:', fullPath)
logger.debug('File contents:', fileData)

// Good: Log minimal identifying info
logger.info('Processing file:', path.basename(fullPath))
logger.debug('File size:', fileData.length)
```

### Secure IPC Responses

Don't expose internal paths or system information:

```typescript
// Bad: Exposing full system paths
return {
  path: '/Users/name/Documents/secret/file.txt',
  config: appConfig  // May contain sensitive defaults
}

// Good: Return only what renderer needs
return {
  filename: path.basename(filePath),
  size: stats.size,
  modifiedAt: stats.mtime.getTime()
}
```

## Error Handling Security

### Sanitize Error Messages

Don't expose system details in error messages sent to renderer:

```typescript
try {
  await fs.readFile(filePath)
} catch (error) {
  // Bad: Exposes file path to renderer
  throw error
  
  // Good: Generic error for renderer
  logger.error('File read error:', error)
  throw new Error('Failed to read file')
}
```

## Preload Script Safety

### Minimal API Surface

Only expose what's absolutely necessary:

```typescript
// preload/index.ts
contextBridge.exposeInMainWorld('api', {
  // Good: Specific, limited functions
  startTransfer: (files: string[]) => ipcRenderer.invoke('transfer:start', files),
  cancelTransfer: () => ipcRenderer.invoke('transfer:cancel'),
  
  // Bad: Generic IPC proxy (exposes all channels)
  invoke: (channel: string, ...args: any[]) => ipcRenderer.invoke(channel, ...args),
})
```

### Type-Safe Event Listeners

```typescript
// Good: Specific typed listeners
onTransferProgress: (callback: (progress: TransferProgress) => void) => {
  const handler = (_: IpcRendererEvent, progress: TransferProgress) => callback(progress)
  ipcRenderer.on('transfer:progress', handler)
  return () => ipcRenderer.removeListener('transfer:progress', handler)
},

// Bad: Generic listener
on: (channel: string, callback: Function) => ipcRenderer.on(channel, callback)
```

## Checklist Before Code Review

- [ ] All IPC handlers validate their inputs
- [ ] Paths from renderer are validated and sanitized
- [ ] No `nodeIntegration: true` or `contextIsolation: false`
- [ ] No `shell: true` with user input
- [ ] Error messages don't expose system details
- [ ] Preload exposes minimal, specific APIs
- [ ] Navigation is restricted to known URLs
- [ ] No sensitive data in logs
