---
description: Testing patterns for TransferBox Electron app with Jest
globs: ["tests/**/*.ts", "tests/**/*.tsx", "**/*.test.ts", "**/*.test.tsx"]
alwaysApply: false
---

# Testing Guidelines

## Test File Organization

### Directory Structure
```
tests/
├── main/           # Main process tests (node environment)
├── renderer/       # Renderer tests (jsdom environment)
├── integration/    # Cross-module integration tests
├── shared/         # Shared type/utility tests
└── __mocks__/      # Shared mocks (electron.ts, etc.)
```

### Test File Naming
- Unit tests: `moduleName.test.ts`
- Integration tests: `feature.integration.test.ts`
- Test utilities: `testUtils.ts` (no `.test` suffix)

## Running Tests

```bash
npm test                  # All tests
npm run test:main         # Main process only
npm run test:renderer     # Renderer only
npm run test:watch        # Watch mode
npm run test:coverage     # With coverage report
```

## Testing Main Process Code

### Mocking Electron APIs

Use the shared mock at `tests/__mocks__/electron.ts`:

```typescript
// Automatic mock - just import
jest.mock('electron')

import { app, BrowserWindow, ipcMain } from 'electron'
```

### File System Operations

Use temporary directories for file operation tests:

```typescript
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

describe('FileTransfer', () => {
  let tempDir: string
  
  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'transferbox-test-'))
  })
  
  afterEach(async () => {
    await fs.rm(tempDir, { recursive: true, force: true })
  })
  
  it('should transfer file atomically', async () => {
    // Create test file
    const sourcePath = path.join(tempDir, 'source.txt')
    await fs.writeFile(sourcePath, 'test content')
    
    // Test transfer
    const destPath = path.join(tempDir, 'dest.txt')
    await transferFile(sourcePath, destPath)
    
    // Verify
    const content = await fs.readFile(destPath, 'utf-8')
    expect(content).toBe('test content')
  })
})
```

### IPC Handler Testing

Test IPC handlers in isolation:

```typescript
import { ipcMain } from 'electron'
import { setupIpcHandlers } from '../../src/main/ipc'

describe('IPC Handlers', () => {
  let handlers: Map<string, Function>
  
  beforeEach(() => {
    handlers = new Map()
    
    // Capture registered handlers
    jest.spyOn(ipcMain, 'handle').mockImplementation((channel, handler) => {
      handlers.set(channel, handler)
      return ipcMain
    })
    
    setupIpcHandlers()
  })
  
  it('should handle scanDrive request', async () => {
    const handler = handlers.get('drive:scan')
    const mockEvent = { sender: {} }
    
    const result = await handler(mockEvent, '/path/to/drive')
    
    expect(result).toEqual(expect.arrayContaining([
      expect.objectContaining({ name: expect.any(String) })
    ]))
  })
})
```

## Testing Renderer Components

### Component Testing Pattern

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { FileList } from '../../src/renderer/src/components/FileList'

describe('FileList', () => {
  const mockFiles = [
    { id: '1', name: 'file1.txt', size: 1000 },
    { id: '2', name: 'file2.txt', size: 2000 },
  ]
  
  it('renders file list', () => {
    render(<FileList files={mockFiles} onSelect={jest.fn()} />)
    
    expect(screen.getByText('file1.txt')).toBeInTheDocument()
    expect(screen.getByText('file2.txt')).toBeInTheDocument()
  })
  
  it('calls onSelect when file is clicked', () => {
    const onSelect = jest.fn()
    render(<FileList files={mockFiles} onSelect={onSelect} />)
    
    fireEvent.click(screen.getByText('file1.txt'))
    
    expect(onSelect).toHaveBeenCalledWith(mockFiles[0])
  })
})
```

### Testing with Zustand Store

Create a test store wrapper:

```typescript
import { create } from 'zustand'
import type { StoreState } from '../../src/renderer/src/store'

// Create test store with initial state
export const createTestStore = (initialState: Partial<StoreState> = {}) => {
  return create<StoreState>((set, get) => ({
    // Default test state
    drives: [],
    selectedDrive: null,
    // ... other defaults
    ...initialState,
    // Actions
    setSelectedDrive: (drive) => set({ selectedDrive: drive }),
  }))
}

// Usage in tests
import { StoreProvider } from '../../src/renderer/src/store'

const renderWithStore = (ui: ReactElement, initialState = {}) => {
  const store = createTestStore(initialState)
  return render(
    <StoreProvider value={store}>
      {ui}
    </StoreProvider>
  )
}

it('shows selected drive', () => {
  renderWithStore(<DriveSelector />, {
    drives: mockDrives,
    selectedDrive: mockDrives[0],
  })
  
  expect(screen.getByText(mockDrives[0].label)).toHaveClass('selected')
})
```

### Mocking window.api

```typescript
// Setup in test file or setupTests.ts
const mockApi = {
  startTransfer: jest.fn(),
  cancelTransfer: jest.fn(),
  getConfig: jest.fn().mockResolvedValue({}),
  onTransferProgress: jest.fn().mockReturnValue(() => {}),
}

beforeEach(() => {
  window.api = mockApi
  jest.clearAllMocks()
})

it('calls startTransfer on button click', async () => {
  render(<TransferButton files={mockFiles} />)
  
  fireEvent.click(screen.getByRole('button', { name: /start/i }))
  
  await waitFor(() => {
    expect(mockApi.startTransfer).toHaveBeenCalledWith(mockFiles)
  })
})
```

## Async Testing Patterns

### Using waitFor

```typescript
it('shows success message after transfer', async () => {
  mockApi.startTransfer.mockResolvedValue({ success: true })
  
  render(<TransferPanel />)
  fireEvent.click(screen.getByText('Start Transfer'))
  
  await waitFor(() => {
    expect(screen.getByText('Transfer complete')).toBeInTheDocument()
  })
})
```

### Testing Loading States

```typescript
it('shows loading state during transfer', async () => {
  // Create a promise we can control
  let resolveTransfer: Function
  mockApi.startTransfer.mockReturnValue(
    new Promise(resolve => { resolveTransfer = resolve })
  )
  
  render(<TransferPanel />)
  fireEvent.click(screen.getByText('Start'))
  
  // Check loading state
  expect(screen.getByText('Transferring...')).toBeInTheDocument()
  expect(screen.getByRole('button', { name: /start/i })).toBeDisabled()
  
  // Resolve and check final state
  resolveTransfer({ success: true })
  
  await waitFor(() => {
    expect(screen.queryByText('Transferring...')).not.toBeInTheDocument()
  })
})
```

## Test Data Factories

Create factories for consistent test data:

```typescript
// tests/factories/fileFactory.ts
import type { FileInfo } from '../../src/shared/types'

export const createFileInfo = (overrides: Partial<FileInfo> = {}): FileInfo => ({
  id: `file-${Math.random().toString(36).substr(2, 9)}`,
  name: 'test-file.txt',
  path: '/path/to/test-file.txt',
  size: 1024,
  modifiedAt: Date.now(),
  ...overrides,
})

export const createFileList = (count: number): FileInfo[] =>
  Array.from({ length: count }, (_, i) =>
    createFileInfo({ name: `file-${i}.txt` })
  )
```

## Testing Error Scenarios

```typescript
describe('error handling', () => {
  it('shows error message on transfer failure', async () => {
    mockApi.startTransfer.mockRejectedValue(new Error('Disk full'))
    
    render(<TransferPanel />)
    fireEvent.click(screen.getByText('Start'))
    
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent('Disk full')
    })
  })
  
  it('allows retry after error', async () => {
    mockApi.startTransfer
      .mockRejectedValueOnce(new Error('Network error'))
      .mockResolvedValueOnce({ success: true })
    
    render(<TransferPanel />)
    
    // First attempt fails
    fireEvent.click(screen.getByText('Start'))
    await waitFor(() => screen.getByRole('alert'))
    
    // Retry succeeds
    fireEvent.click(screen.getByText('Retry'))
    await waitFor(() => {
      expect(screen.getByText('Transfer complete')).toBeInTheDocument()
    })
  })
})
```

## Snapshot Testing

Use sparingly for complex UI that shouldn't change unexpectedly:

```typescript
it('matches snapshot', () => {
  const { container } = render(<Header />)
  expect(container.firstChild).toMatchSnapshot()
})
```

## Coverage Requirements

Aim for coverage on:
- Main process modules in `src/main/**/*.ts` (excluding `index.ts`)
- Preload scripts in `src/preload/**/*.ts`
- Critical renderer components and hooks

Run `npm run test:coverage` to generate reports in `coverage/`.

## Test-Driven Development Workflow

1. **Write failing test first**
2. **Implement minimal code to pass**
3. **Refactor while keeping tests green**
4. **Repeat**

```typescript
// 1. Write the test first
describe('formatFileSize', () => {
  it('formats bytes correctly', () => {
    expect(formatFileSize(1024)).toBe('1 KB')
    expect(formatFileSize(1048576)).toBe('1 MB')
  })
})

// 2. Then implement
export const formatFileSize = (bytes: number): string => {
  // Implementation
}
```
